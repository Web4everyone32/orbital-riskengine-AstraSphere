<!DOCTYPE html>
<html>
<head>
  <title>AstraSphere – Orbital Intelligence</title>

  <script src="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Widgets/widgets.css" rel="stylesheet">

  <link rel="stylesheet" href="/static/astra.css">
</head>

<body>

<div id="cesiumContainer"></div>

<div id="panel">
  <h2>AstraSphere</h2>
  <p class="subtitle">Orbital Intelligence Platform</p>

  <div id="details">Click a satellite</div>

  <div class="legend">
    <span class="low">● LOW RISK</span>
    <span class="medium">● MEDIUM RISK</span>
    <span class="high">● HIGH RISK</span>
  </div>

  <div class="risk-note">
    Red orbital bands indicate regions of high object density and
    elevated conjunction probability over the next 24–48 hours.
  </div>

  <div class="time-note">
    Use the time slider to observe orbital motion and evolving congestion.
  </div>
</div>

<script>
  /* ==============================
     CESIUM VIEWER (EARTH FIRST)
     ============================== */

  const viewer = new Cesium.Viewer('cesiumContainer', {
    animation: true,
    timeline: true,
    baseLayerPicker: false,
    geocoder: false,
    homeButton: false,
    sceneModePicker: false,
    infoBox: false,
    selectionIndicator: true
  });

  /* ---- VISUAL CLEANUP ---- */
  viewer.scene.skyBox.show = false;              // Remove star dominance
  viewer.scene.sun.show = false;                 // Remove blinding sun
  viewer.scene.moon.show = false;
  viewer.scene.backgroundColor = Cesium.Color.BLACK;

  viewer.scene.globe.enableLighting = true;
  viewer.scene.globe.baseColor = Cesium.Color.DARKGRAY;

  /* ---- LOCK CAMERA TO EARTH ---- */
  viewer.camera.setView({
    destination: Cesium.Cartesian3.fromDegrees(0, 0, 14000000)
  });

  viewer.scene.screenSpaceCameraController.minimumZoomDistance = 7000000;
  viewer.scene.screenSpaceCameraController.maximumZoomDistance = 40000000;

  const satelliteEntities = {};

  /* ==============================
     ORBIT VISUALS
     ============================== */

  function drawOrbit(altitudeKm, color) {
    const positions = [];
    const radius = 6378137 + altitudeKm * 1000;

    for (let i = 0; i <= 360; i += 3) {
      positions.push(
        Cesium.Cartesian3.fromRadians(
          Cesium.Math.toRadians(i),
          0,
          radius
        )
      );
    }

    viewer.entities.add({
      polyline: {
        positions,
        width: 1.2,
        material: color.withAlpha(0.7)
      }
    });
  }

  function drawShell(altitudeKm, color) {
    viewer.entities.add({
      ellipsoid: {
        radii: new Cesium.Cartesian3(
          6378137 + altitudeKm * 1000,
          6378137 + altitudeKm * 1000,
          6378137 + altitudeKm * 1000
        ),
        material: color.withAlpha(0.07),
        outline: true,
        outlineColor: color.withAlpha(0.25)
      }
    });
  }

  function drawConjunctionZone(altitudeKm) {
    const positions = [];
    const radius = 6378137 + altitudeKm * 1000;

    for (let i = 0; i <= 360; i += 6) {
      positions.push(
        Cesium.Cartesian3.fromRadians(
          Cesium.Math.toRadians(i),
          Cesium.Math.toRadians(10),
          radius
        )
      );
    }

    viewer.entities.add({
      polyline: {
        positions,
        width: 4,
        material: Cesium.Color.RED.withAlpha(0.45)
      }
    });
  }

  /* ---- STATIC CONTEXT ---- */
  drawOrbit(400, Cesium.Color.GREEN);
  drawOrbit(550, Cesium.Color.ORANGE);
  drawOrbit(700, Cesium.Color.RED);

  fetch("/orbit/risk?altitude_km=550&inclination_deg=97")
    .then(r => r.json())
    .then(risk => {
      const colorMap = {
        LOW: Cesium.Color.GREEN,
        MEDIUM: Cesium.Color.ORANGE,
        HIGH: Cesium.Color.RED,
        CRITICAL: Cesium.Color.DARKRED
      };

      drawShell(550, colorMap[risk.risk.level]);
      drawConjunctionZone(550);
    });

  /* ==============================
     SATELLITES (NEAR REAL TIME)
     ============================== */

  async function updateSatellites() {
    const sats = await fetch("/api/satellites").then(r => r.json());

    for (const sat of sats) {
      const position = Cesium.Cartesian3.fromDegrees(
        sat.lon,
        sat.lat,
        sat.altitude_km * 1000
      );

      if (!satelliteEntities[sat.id]) {
        satelliteEntities[sat.id] = viewer.entities.add({
          id: sat.id,
          name: sat.name,
          position,
          point: {
            pixelSize: 9,
            color: Cesium.Color.CYAN,
            outlineColor: Cesium.Color.WHITE,
            outlineWidth: 1
          },
          label: {
            text: sat.name,
            font: "11px sans-serif",
            fillColor: Cesium.Color.WHITE,
            pixelOffset: new Cesium.Cartesian2(0, -16),
            showBackground: true,
            backgroundColor: Cesium.Color.BLACK.withAlpha(0.6),
            scale: 0.6
          }
        });
      } else {
        satelliteEntities[sat.id].position = position;
      }
    }
  }

  viewer.selectedEntityChanged.addEventListener(async function(entity) {
    if (!entity) return;

    const sats = await fetch("/api/satellites").then(r => r.json());
    const sat = sats.find(s => s.id === entity.id);

    const risk = await fetch(
      `/orbit/risk?altitude_km=${sat.altitude_km}&inclination_deg=${sat.inclination_deg}`
    ).then(r => r.json());

    document.getElementById("details").innerHTML = `
      <b>${sat.name}</b><br/><br/>
      Orbit Shell: ${risk.orbit_shell}<br/>
      Congestion Index: ${risk.metrics.congestion_index}<br/>
      Collision Probability: ${risk.metrics.collision_probability}<br/>
      <span style="color:${risk.risk.color}">
        Risk Level: ${risk.risk.level}
      </span>
    `;
  });

  setInterval(updateSatellites, 3000);
</script>

</body>
</html>
